using LernUnityAdventure_m24_25;
using System;
using UnityEngine;

namespace LernUnityAdventure_m22_23
{
    [RequireComponent(typeof(SphereCollider))]
    public class DelayedExplosion : MonoBehaviour
    {
        [SerializeField] private float _damage;
        [SerializeField] private float _force;
        [SerializeField] private float _radiusExplosion;
        [SerializeField] private float _radiusActivation;
        [SerializeField] private float _countdownToExplosion;

        [SerializeField] private ExplosionTriggerTypes _triggerType;
        [SerializeField] private ExplosionCleanupTypes _cleanupType;

        private IExplosionTriggerStrategy _trigger;
        private IExplosionCleanupStrategy _cleanup;

        private bool _isExplodes = false;
        private bool _isExploded = false;
        private bool _hasVfxPlayed = false;

        public float RadiusExplosion => _radiusExplosion;
        public bool IsExploded => _isExploded;
        public bool IsExplodes => _isExplodes;
        public bool HasVfxPlayed => _hasVfxPlayed;
        public void SetVfxPlayed() => _hasVfxPlayed = true;

        public void Awake()
        {
            _trigger = CreateTrigger();
            _cleanup = CreateCleanup();

            _trigger.Initialize(this);
            _cleanup.Initialize(this);

            if (TryGetComponent(out SphereCollider collider))
            {
                collider.radius = _radiusActivation;
            }
        }

        private IExplosionCleanupStrategy CreateCleanup()
        {
            switch (_cleanupType)
            {
                case ExplosionCleanupTypes.Vfx:
                    return new WaitVfxCleanup();

                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        private IExplosionTriggerStrategy CreateTrigger()
        {
            switch (_triggerType)
            {
                case ExplosionTriggerTypes.Timer:
                    return new TimerExplosionTrigger(_countdownToExplosion);

                case ExplosionTriggerTypes.Coroutine:
                    return new CoroutineExplosionTrigger(this, _countdownToExplosion);

                default:
                    throw new ArgumentOutOfRangeException();
            }
        }

        public void Update()
        {
            _trigger.Tick(Time.deltaTime);
            _cleanup.Tick(Time.deltaTime);
        }

        public void OnTriggerEnter(Collider other)
        {
            if (_isExplodes) return;

            _isExplodes = true;
        }

        public void OnDrawGizmos()
        {
            Gizmos.color = Color.red;
            Gizmos.DrawWireSphere(transform.position, _radiusExplosion);

            Gizmos.color = Color.green;
            Gizmos.DrawWireSphere(transform.position, _radiusActivation);
        }

        public void Explode()
        {
            _isExplodes = false;

            Collider[] targets = Physics.OverlapSphere(transform.position, _radiusExplosion);
            ExplosionData data = new ExplosionData(transform.position, _force, _radiusExplosion, _damage);

            foreach (Collider target in targets)
            {
                if (target.TryGetComponent(out IExplodable explodable) == false)
                    continue;

                explodable.OnExplode(data);
            }

            _isExploded = true;
        }
    }
}
